# Algorithm for Coding Test

---
# 1. Greedy Algorithm
* 그리디 알고리즘(탐욕법)은 현재 상황에서 지금 당장 좋은 것만 고르는 방법이다.
* 단순히 가장 좋아 보이는 것을 반복적으로 선택해도 최적의 해를 구할 수 있는지 검토하는 것이 중요하다.
* 일반적인 상황에서 그리디 알고리즘은 최적의 해를 보장할 수 없을 때가 많지만, 코딩 테스트에서는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에 한하여 출제된다.
* 예제
> 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수를 구하시오. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.

``` python
N = int(input())
count = 0
coins = [500, 100, 50, 10]

for coin in coins:
    count += N // coin
    N %= coin

print(count)
```


---
# 2. Implementation
* 구현 유형의 문제는 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제를 지칭한다.
* 시뮬레이션, 완전 탐색 유형과 비슷한 점이 많다.
* 예제
> 여행가 A는 1X1 크기의 정사각형으로 나누어져 있는 NxN 크기의 정사각형 공간 위에 서있다. 가장 왼쪽 위 좌표는 (1, 1)이며, 가장 오른쪽 아래 좌표는 (N, N)에 해당한다. A는 상/하/좌/우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1, 1)이다. 계획서에는 L(왼)/R(오른)/U(아래)/D(위) 문자가 적혀있으며 각 방향으로 한 칸씩 이동함을 의미한다. 이 때 NxN 크기의 정사각형 공간을 벗어나는 움직임은 무시된다. A가 최종적으로 도착할 지점의 좌표를 공백을 기준으로 구분하여 출력하라.

```python
N = int(input())
plans = input().split()
x, y = 1, 1

# L, R, U, D 이동방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

for plan in plans:
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]
    # 공간을 벗어나는 경우 무시
    if nx < 1 or ny <1 or nx > N or ny > N:
        continue
    x, y = nx, ny

print(x, y)
```
